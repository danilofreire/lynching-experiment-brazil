---
title: |
       | Supplementary Materials for "Casting the First Stone: Understanding Attitudes towards Lynching in Brazil"
author:
- "Danilo Freire[^freire]"
- "David Skarbek[^skarbek]"
date: \today
fontfamily: libertine
fontawesome: yes
fontsize: 12pt
monospace-url: yes
spacing: double
papersize: a4paper
bibliography: ../article/references.bib
biblio-style: apalike
output:
  pdf_document:
    citation_package: natbib
    fig_caption: yes
    number_sections: yes
    toc: true
    keep_tex: yes
    template: template.latex
---

[^freire]: Postdoctoral Research Associate, The Political Theory Project, Brown University, Providence, RI 02912, USA, <danilofreire@gmail.com>, <http://danilofreire.github.io>. Corresponding author.

[^skarbek]: The Department of Political Science and the Political Theory Project, Brown University, Providence, RI, USA, <davidskarbek@brown.edu>, <http://davidskarbek.com>.

```{r setup, echo=FALSE}
plotAMCE <-
    function (x, main = "", xlab = "Change in E[Y]",
              ci = 0.95, colors = NULL,
              xlim = NULL, breaks = NULL,
              labels = NULL, attribute.names = NULL,
              level.names = NULL, label.baseline = TRUE,
              text.size = 11,
              text.color = "black",
              point.size = 0.5, dodge.size = 0.9,
              plot.theme = NULL, plot.display = "all",
              facet.names = NULL,
              facet.levels = NULL,
              group.order = NULL, font.family = NULL,
              tblfy = F, ...) {
        amce_obj <- x
        ylim <- xlim
        pe <- NULL
        se <- NULL
        group <- NULL
        lower <- NULL
        upper <- NULL
        var <- NULL
        printvar <- NULL
        facet <- NULL
        raw_attributes <- names(amce_obj$estimates)
        raw_levels <- lapply(amce_obj$estimates, colnames)
        for (effect in names(raw_levels)) {
            effect_elements <- strsplit(effect, ":")[[1]]
            baseline_interactions <- c()
            for (elem in effect_elements) {
                base_coef <- paste(c(elem, amce_obj$baselines[[elem]]),
                                   collapse = "")
                baseline_interactions <- c(baseline_interactions,
                                           base_coef)
            }
            interaction_str <- paste(baseline_interactions, sep = "",
                                     collapse = ":")
            raw_levels[[effect]] <- c(interaction_str, raw_levels[[effect]])
        }
        if (ci < 1 & ci > 0) {
            zscr <- qnorm(1 - ((1 - ci)/2))
        }
        else {
            cat("Invalid confidence interval -- Defaulting to 95%")
            zscr <- qnorm(1 - ((1 - 0.95)/2))
        }
        if (!is.null(attribute.names)) {
            attribute.names <- unique(attribute.names)
            if (length(attribute.names) != length(raw_attributes)) {
                cat(paste("Error: The number of unique elements in attribute.names ",
                          length(attribute.names), " does not match the attributes in amce object for which estimates were obtained: ",
                          paste(raw_attributes, collapse = ", "), "\n",
                          sep = ""))
                cat("Defaulting attribute.names to attribute names in AMCE object\n")
                attribute.names <- NULL
            }
        }
        if (!is.null(level.names)) {
            names(level.names) <- clean.names(names(level.names))
            for (name in names(level.names)) {
                if (name %in% names(raw_levels)) {
                    if (length(level.names[[name]]) != length(raw_levels[[name]])) {
                        cat(paste("Error: level.names lengths do not match levels for attribute ",
                                  name, "\n", sep = ""))
                        cat(paste("Defaulting level.names for attribute ",
                                  name, " to level names in AMCE object", "\n",
                                  sep = ""))
                        level.names[[name]] <- NULL
                    }
                }
                else {
                    cat(paste("Error: level.names entry ", name,
                              " not in AMCE object. Removing level.names for attribute.",
                              "\n", sep = ""))
                    level.names[[name]] <- NULL
                }
            }
        }
        if (is.null(attribute.names)) {
            attribute.names <- c()
            for (attr in names(amce_obj$estimates)) {
                attr_split <- strsplit(attr, ":")[[1]]
                attr_lookup <- paste(unlist(sapply(attr_split, function(x) amce_obj$user.names[x])),
                                     collapse = ":")
                attribute.names <- c(attribute.names, attr_lookup)
            }
        }
        if (is.null(level.names))
            level.names <- list()
        if (any(!names(raw_levels) %in% names(level.names))) {
            for (attr in names(raw_levels)[!names(raw_levels) %in%
                                           names(level.names)]) {
                attr_split <- strsplit(raw_levels[[attr]], ":")
                level.names[[attr]] <- unlist(lapply(attr_split,
                                                     function(x) paste(sapply(x, function(y) amce_obj$user.levels[y]),
                                                                       collapse = ":")))
            }
        }
        plot.display.opts <- c("all", "unconditional", "interaction")
        if (!is.element(plot.display, plot.display.opts)) {
            stop(paste(c("Error-- plot.display must be once of: ",
                         paste(plot.display.opts, collapse = ", ")), collapse = " "))
        }
        if (!is.null(facet.names)) {
            facet.names <- clean.names(facet.names)
        }
        else if (!is.null(facet.levels)) {
            facet.names <- clean.names(names(facet.levels))
        }
        if (!is.null(facet.names)) {
            facet.names.check <- c()
            for (facet.name in facet.names) {
                if (grepl(":", facet.name))
                    stop("Error-- cannot facet by interaction in current version.")
                if (!facet.name %in% names(amce_obj$estimates) &
                    !facet.name %in% names(amce_obj$cond.estimates)) {
                    stop(paste(c("Error-- cannot find facet name",
                                 facet.name, "in AMCE object output."), collapse = " "))
                }
                else {
                    facet.names.check <- c(facet.names.check, facet.name)
                }
            }
            facet.names <- facet.names.check
        }
        if ((is.null(facet.names)) & (length(amce_obj$respondent.varying) >
                                      0) & (plot.display != "unconditional")) {
            facet.names <- amce_obj$respondent.varying
        }
        if (is.null(facet.names) & plot.display == "interaction") {
            warning("Warning: no facet name or respondent varying characteristic provided to calculate conditional estimates. Will display unconditional only")
            plot.display <- "unconditional"
        }
        if (plot.display == "unconditional" & !is.null(facet.names)) {
            warning("Warning-- plot display is set to unconditional, facet names will be ignored")
            facet.names <- NULL
            facet.levels <- NULL
        }
        if (!is.null(facet.levels)) {
            names(facet.levels) <- clean.names(names(facet.levels))
            for (facet.name in names(facet.levels)) {
                if (facet.name %in% names(amce_obj$baselines)) {
                    facet.levels[[facet.name]] <- clean.names(facet.levels[[facet.name]])
                    if (facet.name %in% names(amce_obj$estimates) &&
                        is.element(amce_obj$baselines[[facet.name]],
                                   facet.levels[[facet.name]])) {
                        stop(paste(c("Error: Facet level \"", as.character(amce_obj$baselines[[facet.name]]),
                                     "\" is the baseline level of a profile varying attribute. Please provide alternative facet level or use defaults."),
                                   collapse = ""))
                    }
                    if (is.null(names(facet.levels[[facet.name]]))) {
                        fac.levs <- sapply(facet.levels[[facet.name]],
                                           function(x) paste(facet.name, x, sep = ""))
                        names(facet.levels[[facet.name]]) <- sapply(fac.levs,
                                                                    USE.NAMES = F, function(x) amce_obj$user.levels[[x]])
                    }
                }
                else if (is.null(names(facet.levels[[facet.name]]))) {
                    names(facet.levels[[facet.name]]) <- as.character(facet.levels[[facet.name]])
                }
            }
        }
        if (is.null(facet.levels))
            facet.levels <- list()
        if (any(!facet.names %in% names(facet.levels))) {
            for (facet.name in facet.names[!facet.names %in% names(facet.levels)]) {
                if (facet.name %in% names(amce_obj$baselines)) {
                    if (facet.name %in% names(amce_obj$estimates)) {
                        fac.levs <- colnames(amce_obj$estimates[[facet.name]])
                    }
                    else {
                        fac.levs <- colnames(amce_obj$cond.estimates[[facet.name]])
                    }
                    facet.levels[[facet.name]] <- sub(facet.name,
                                                      "", fac.levs)
                    facet.levels[[facet.name]] <- c(amce_obj$baselines[[facet.name]],
                                                    facet.levels[[facet.name]])
                    fac.levs <- c(paste(facet.name, amce_obj$baselines[[facet.name]],
                                        sep = ""), fac.levs)
                    names(facet.levels[[facet.name]]) <- sapply(fac.levs,
                                                                USE.NAMES = F, function(x) amce_obj$user.levels[[x]])
                }
                else if (facet.name %in% names(amce_obj$continuous)) {
                    facet.levels[[facet.name]] <- amce_obj$continuous[[facet.name]]
                }
            }
        }
        covariate.values <- list()
        for (var in names(facet.levels)) {
            if (var %in% amce_obj$respondent.varying) {
                covariate.values[[var]] <- facet.levels[[var]]
            }
        }
        d <- data.frame(pe = c(), se = c(), upper = c(), lower = c(),
                        var = c(), printvar = c(), group = c(), facet = c())
        if (plot.display != "interaction") {
            if (plot.display == "all") {
                uncond.facet.name <- "Unconditional"
            }
            else {
                uncond.facet.name <- NA
            }
            if (plot.display == "all" && !is.null(facet.names)) {
                attr_remove <- c()
                for (facet.name in facet.names[!is.element(facet.names,
                                                           amce_obj$respondent.varying)]) {
                    attr_remove1 <- raw_attributes[grepl(":", raw_attributes)]
                    attr_remove1 <- attr_remove1[grepl(facet.name,
                                                       attr_remove1)]
                    attr_remove <- c(attr_remove, attr_remove1)
                }
                raw_attributes <- raw_attributes[!is.element(raw_attributes,
                                                             attr_remove)]
            }
            for (i in 1:length(raw_attributes)) {
                attr_name <- raw_attributes[i]
                print_attr_name <- attribute.names[which(names(amce_obj$estimates) ==
                                                             raw_attributes[i])]
                d_head <- data.frame(pe = NA, se = NA, upper = NA,
                                     lower = NA, var = attr_name, printvar = paste(print_attr_name,
                                                                                   ":", sep = ""), group = "<NA>", facet = uncond.facet.name)
                d <- rbind(d, d_head)
                for (j in 1:length(raw_levels[[attr_name]])) {
                    level_name <- raw_levels[[attr_name]][j]
                    print_level_name <- level.names[[attr_name]][j]
                    if (j == 1) {
                        if (label.baseline) {
                            print_level_name <- paste("(Baseline = ",
                                                      print_level_name, ")", sep = "")
                        }
                        d_lev <- data.frame(pe = NA, se = NA, upper = NA,
                                            lower = NA, var = level_name, printvar = paste("   ",
                                                                                           print_level_name, sep = ""), group = print_attr_name,
                                            facet = uncond.facet.name)
                    }
                    else {
                        val_pe <- amce_obj$estimates[[attr_name]][1,
                                                                  level_name]
                        val_se <- amce_obj$estimates[[attr_name]][2,
                                                                  level_name]
                        upper_bnd <- val_pe + zscr * val_se
                        lower_bnd <- val_pe - zscr * val_se
                        d_lev <- data.frame(pe = val_pe, se = val_se,
                                            upper = upper_bnd, lower = lower_bnd, var = level_name,
                                            printvar = paste("   ", print_level_name,
                                                             sep = ""), group = print_attr_name, facet = uncond.facet.name)
                    }
                    d <- rbind(d, d_lev)
                }
            }
        }
        if (plot.display != "unconditional" & !is.null(facet.names)) {
            for (facet.name in facet.names) {
                print_facet_name <- amce_obj$user.names[[facet.name]]
                all_req_vars <- attr(terms(amce_obj$formula), "term.labels")
                all_mod <- unlist(sapply(all_req_vars, function(x) {
                    y <- strsplit(x, ":")[[1]]
                    if (any(y == facet.name))
                        x
                }))
                all_mod <- unlist(sapply(all_mod, function(x) {
                    subs <- strsplit(x, ":")[[1]]
                    subs <- subs[is.element(subs, names(amce_obj$estimates))]
                    subs <- subs[subs != facet.name]
                    if (length(subs) > 0)
                        paste(subs, collapse = ":")
                }))
                if (length(all_mod) == 0) {
                    stop(paste(c("Error: Facet variable", facet.name,
                                 "not interacted with profile attributes"),
                               collapse = " "))
                }
                all_mod <- unique(all_mod)
                if (is.element(facet.name, names(amce_obj$estimates))) {
                    facet.start <- 2
                }
                else {
                    facet.start <- 1
                }
                for (k in facet.start:length(facet.levels[[facet.name]])) {
                    facet_lev <- facet.levels[[facet.name]][k]
                    if (is.element(facet.name, names(amce_obj$estimates))) {
                        print_facet_level <- paste(c("ACIE", paste(c(print_facet_name,
                                                                     names(facet.levels[[facet.name]])[k]), collapse = " = ")),
                                                   collapse = "\n")
                    }
                    else {
                        print_facet_level <- paste(c("Conditional on",
                                                     paste(c(print_facet_name, names(facet.levels[[facet.name]])[k]),
                                                           collapse = " = ")), collapse = "\n")
                    }
                    for (mod_var in all_mod) {
                        print_attr_name <- attribute.names[which(names(amce_obj$estimates) ==
                                                                     mod_var)]
                        d_head <- data.frame(pe = NA, se = NA, upper = NA,
                                             lower = NA, var = mod_var, printvar = paste(print_attr_name,
                                                                                         ":", sep = ""), group = "<NA>", facet = print_facet_level)
                        d <- rbind(d, d_head)
                        if (facet.name %in% names(amce_obj$estimates)) {
                            inter_coef <- paste(sort(c(mod_var, facet.name)),
                                                collapse = ":")
                            estimate.source <- amce_obj$estimates[[inter_coef]]
                            estimate.source <- estimate.source[, grep(paste0(facet.name,
                                                                             facet_lev), colnames(estimate.source))]
                        }
                        else {
                            estimate.source <- get.conditional.effects(amce_obj,
                                                                       covariate.values, facet.name, facet_lev,
                                                                       mod_var)
                        }
                        mod_vars <- strsplit(mod_var, ":")[[1]]
                        for (p in 1:length(raw_levels[[mod_var]])) {
                            mod_coef <- raw_levels[[mod_var]][p]
                            mod_coefs <- strsplit(mod_coef, ":")[[1]]
                            for (lev in 1:length(mod_coefs)) {
                                mod_lev <- sub(mod_vars[lev], "", mod_coefs[lev])
                            }
                            print_level_name <- level.names[[mod_var]][p]
                            if (p == 1) {
                                if (label.baseline) {
                                    print_level_name <- paste("(Baseline = ",
                                                              print_level_name, ")", sep = "")
                                }
                                d_lev <- data.frame(pe = NA, se = NA, upper = NA,
                                                    lower = NA, var = mod_coef, printvar = paste("   ",
                                                                                                 print_level_name, sep = ""), group = print_attr_name,
                                                    facet = print_facet_level)
                            }
                            else {
                                val_pe <- estimate.source[1, p - 1]
                                if (!is.na(val_pe)) {
                                    val_se <- estimate.source[2, p - 1]
                                    upper_bnd <- val_pe + zscr * val_se
                                    lower_bnd <- val_pe - zscr * val_se
                                }
                                else {
                                    val_se <- upper_bnd <- lower_bnd <- NA
                                }
                                d_lev <- data.frame(pe = val_pe, se = val_se,
                                                    upper = upper_bnd, lower = lower_bnd,
                                                    var = mod_coef, printvar = paste("   ",
                                                                                     print_level_name, sep = ""), group = print_attr_name,
                                                    facet = print_facet_level)
                            }
                            d <- rbind(d, d_lev)
                        }
                    }
                }
            }
        }
        else {
            d <- d[, -which(colnames(d) == "facet")]
        }
        if (is.null(ylim)) {
            max_upper <- max(d$upper, na.rm = T) + 0.05
            min_lower <- min(d$lower, na.rm = T) - 0.05
            ylim <- c(min_lower, max_upper)
            d[is.na(d)] <- max_upper + 100
        }
        else {
            d[is.na(d)] <- max(ylim) + 100
        }
        d$group[d$group == "<NA>"] <- NA
        if (!is.null(facet.names))
            d$facet[d$facet == "<NA>"] <- NA
        d$var <- factor(d$var, levels = unique(d$var)[length(d$var):1])
        if (!is.null(facet.names)) {
            d$facet <- factor(d$facet, levels = unique(d$facet))
        }
        if (!is.null(group.order)) {
            n.row <- length(unique(as.character(d$var)))
            order.var <- vector("character", length = n.row)
            i <- 1
            while (i < n.row) {
                for (j in group.order) {
                    order.var[i] <- unique(as.character(d$var[d$var ==
                                                                  gsub(" ", "", j)]))
                    i <- i + 1
                    temp.d <- d
                    temp.d$group <- gsub(" ", "", temp.d$group)
                    temp.d <- subset(temp.d, group == gsub(" ", "",
                                                           j))
                    temp.var <- unique((as.character(temp.d$var)))
                    order.var[i:(i + length(temp.var) - 1)] <- temp.var
                    i <- i + length(temp.var)
                }
            }
            order.var <- rev(order.var)
            order.df <- data.frame(order.var, 1:length(order.var))
            colnames(order.df) <- c("var", "order")
            d$var <- factor(d$var, levels = order.var)
            d <- merge(d, order.df, by.x = "var", by.y = "var", suffixes = c("",
                                                                             ""))
        }
        levs <- as.character(d$printvar)
        levs <- gsub('organizations', 'organisations', levs)
        d$printvar <- factor(levs, levels = levs)
        if(tblfy) {
            return(d)
        }
        p = ggplot(d, aes(y = pe, x = var, colour = group))
        p = p + coord_flip(ylim = ylim)
        p = p + geom_hline(yintercept = 0, size = 0.5, colour = "black",
                           linetype = "dotted")
        p = p + geom_pointrange(aes(ymin = lower, ymax = upper),
                                position = position_dodge(width = dodge.size), size = point.size)
        if (!is.null(facet.names)) {
            p = p + facet_wrap(~facet)
        }
        if (is.null(breaks) & is.null(labels)) {
            p = p + scale_y_continuous(name = xlab)
        }
        else if (is.null(breaks) & !is.null(labels)) {
            p = p + scale_y_continuous(name = xlab, labels = labels)
        }
        else if (!is.null(breaks) & is.null(labels)) {
            p = p + scale_y_continuous(name = xlab, breaks = breaks)
        }
        else if (!is.null(breaks) & !is.null(labels)) {
            p = p + scale_y_continuous(name = xlab, breaks = breaks,
                                       labels = labels)
        }
        if (!is.null(group.order)) {
            fix.xlabs.df <- d[!duplicated(d$var), ]
            fix.xlabs <- fix.xlabs.df[order(-fix.xlabs.df$order),
                                      ]$printvar
        }
        else {
            fix.xlabs <- as.character(d$printvar)[!duplicated(d$var)]
        }
        p = p + scale_x_discrete(name = "", labels = fix.xlabs[length(fix.xlabs):1])
        if (!is.null(main)) {
            if (main != "") {
                p = p + ggtitle(main)
            }
        }
        if (is.null(colors)) {
            p = p + scale_colour_discrete(" ")
        }
        else if (is.vector(colors)) {
            cPal <- rep(colors, ceiling(length(unique(d$group))/length(colors)))
            p = p + scale_colour_manual(values = cPal)
        }
        else {
            cat("Error: 'colors' must be a vector. Using default colors\n")
            p = p + scale_colour_discrete(" ")
        }
        if (is.null(plot.theme)) {
            theme_bw1 <- function(base_size = text.size, base_family = "") {
                theme_grey(base_size = base_size, base_family = base_family) %+replace%
                    theme(axis.text.x = element_text(size = base_size *
                                                         0.9, colour = text.color, hjust = 0.5, vjust = 1),
                          axis.text.y = element_text(size = base_size,
                                                     colour = text.color, hjust = 0, vjust = 0.5,
                                                     family = font.family), axis.ticks = element_line(colour = "grey50"),
                          axis.title.y = element_text(size = base_size,
                                                      angle = 90, vjust = 0.01, hjust = 0.1, family = font.family),
                          plot.title = element_text(face = "bold", family = font.family),
                          legend.position = "none")
            }
            p = p + theme_bw1()
            print(p)
        }
        else if (is.null(class(plot.theme))) {
            cat("Error: 'plot.theme' is not a valid ggplot theme object. Using default theme\n")
            theme_bw1 <- function(base_size = text.size, base_family = "") {
                theme_grey(base_size = base_size, base_family = base_family) %+replace%
                    theme(axis.text.x = element_text(size = base_size *
                                                         0.9, colour = text.color, hjust = 0.5, vjust = 1),
                          axis.text.y = element_text(size = base_size,
                                                     colour = text.color, hjust = 0, vjust = 0.5,
                                                     family = font.family), axis.ticks = element_line(colour = "grey50"),
                          axis.title.y = element_text(size = base_size,
                                                      angle = 90, vjust = 0.01, hjust = 0.1, family = font.family),
                          plot.title = element_text(face = "bold", family = font.family),
                          legend.position = "none")
            }
            p = p + theme_bw1()
            print(p)
        }
        else if (class(plot.theme)[1] != "theme") {
            cat("Error: 'plot.theme' is not a valid ggplot theme object. Using default theme\n")
            theme_bw1 <- function(base_size = text.size, base_family = "") {
                theme_grey(base_size = base_size, base_family = base_family) %+replace%
                    theme(axis.text.x = element_text(size = base_size *
                                                         0.9, colour = text.color, hjust = 0.5, vjust = 1),
                          axis.text.y = element_text(size = base_size,
                                                     colour = text.color, hjust = 0, vjust = 0.5,
                                                     family = font.family), axis.ticks = element_line(colour = "grey50"),
                          axis.title.y = element_text(size = base_size,
                                                      angle = 90, vjust = 0.01, hjust = 0.1, family = font.family),
                          plot.title = element_text(face = "bold", family = font.family),
                          legend.position = "none")
            }
            p = p + theme_bw1()
            print(p)
        }
        else {
            p = p + plot.theme
            print(p)
        }
        if (length(covariate.values) > 1) {
            resp.message <- c("Note:")
            for (this.var in names(covariate.values)) {
                resp.message <- paste(c(resp.message, " For AMCE and ACIE conditional on ",
                                        this.var, ", "), collapse = "")
                other.vars <- names(covariate.values)[names(covariate.values) !=
                                                          this.var]
                other.levels <- c()
                for (var in other.vars) {
                    other.levels <- c(other.levels, paste(c(var,
                                                            " will be held at level \"", names(covariate.values[[var]])[1],
                                                            "\""), collapse = ""))
                }
                other.levels <- paste(other.levels, collapse = ", and ")
                resp.message <- c(resp.message, other.levels, ".")
                resp.message <- paste(resp.message, collapse = "")
            }
            cat(resp.message, "\n")
        }
    }
```

# Descriptive Statistics
\label{sec:descriptive}

\setlength{\parindent}{1cm}
\setlength{\parskip}{0pt}

From October 1 to December 5, 2018, we ran an elite survey with respondents from ten Latin American countries: Argentina, Bolivia, Brazil, Chile, Colombia, Costa Rica, Ecuador, Mexico, Panama, and Peru. The survey proceeded in two steps.

We collected information on Latin American elites. The target was:

1. Members of the Executive branch
2. Members of the Legislative branch
3. Civil society
4. Academics

For each profile, in each country, we aimed at surveying:

1. 10 members of the Executive branch
2. 10 members of the Legislative branch
3. 15 Civil society
4. 15 Academics

To do so, we built a prospective respondents dataset with ten times these members for each country. Then, we ran an online and telephone survey where we collected information regarding the climate change agreements and other climate
change-related problems.

After finishing this dataset, we started the surveying stage. From November 12 to December 5, we ran the survey by contacting elite members by phone or by email. We had two teams of enumerators, one based in São Paulo and another based in Rio de Janeiro, Brazil, comprised of Portuguese and Spanish native speakers. Although the overall aim of the survey was 500 responses, the teams managed to collect 654 interviews.

# Descriptive Statistics \label{sec:descstats}

The main demographic statistics collected were the country and elite types, and the geolocation of the respondents. They follow in the graphs below.

```{r demogGraph, echo=FALSE, fig.align='center', fig.height=3.5, message=FALSE,warning=F}
library(plm); library(tidyverse)
library(haven); library(clusterSEs)
library(stargazer); library(cjoint)
library(sp); library(cregg)
library(kableExtra)
load('freire-mignozzetti-skarbek.RData')

aux <- cj %>%
  select(Response.ID, countryOrigin, groupOrigin, LocationLongitude, LocationLatitude) %>%
  unique()

# Country
tab <- data.frame(table(aux$countryOrigin))
names(tab) <- c('Country', 'Frequency')
p<- ggplot(data = tab, aes(x = Country, y = Frequency)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 50, linetype = "dashed", color = "black") +
  theme_bw() + annotate(geom = "text", label = tab$Frequency,
                        x = tab$Country, y = tab$Frequency + 2)
p

# Elite type
tab <- data.frame(table(aux$groupOrigin))
names(tab) <- c('Group Origin', 'Frequency')
p<- ggplot(data = tab, aes(x = `Group Origin`, y = Frequency)) +
  geom_bar(stat = "identity") +
  theme_bw() + annotate(geom = "text", label = tab$Frequency,
                        x = tab$`Group Origin`, y = tab$Frequency + 5)
p
```

As we can see, we managed to contact more than fifty elite members for all countries but Bolivia and Peru. To compensate for the low collection rates in these two countries, note that we exceeded the sample size in all the remaining states.

Considering the elite type, note that we have, as expected, more people from academia and the civil society, followed by those from the Executive and Legislative branches. The data collection for members of the Legislative branch was below the original target, but above the minimum mark of 5 for each country. This is expected, given the difficulty of accessing these elite members.

In the map, we can see that the answers concentrate on the country's capitals, with some variation within the state, but with sample concentrated in the largest municipalities. This is also in line with our expectations, as elite members are assumed to gravitate around capital cities and large urban centers.

# Frequency of Features Selected by Each Attribute \label{sec:features}

The figures below display the feature frequency for each attribute, by each task.

```{r attributes, echo=FALSE, fig.align='center', fig.height=4}
aux <- cj %>%
  select(Response.ID, `Who makes the rules?`, `How are conflicts resolved?`, `What punishments do they use?`,`How are repeated violations punished?`, `How are costs distributed?`,`How often will the agreement be renegotiated?`) %>%
  unique()

# Who makes the rules
tab <- data.frame(table(aux$`Who makes the rules?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('Who makes the rules?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 35) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are conflicts resolved?
tab <- data.frame(table(aux$`How are conflicts resolved?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are conflicts resolved?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 35) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# What punishments do they use?
tab <- data.frame(table(aux$`What punishments do they use?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('What punishments do they use?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 40) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are repeated violations punished?
tab <- data.frame(table(aux$`How are repeated violations punished?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are repeated violations punished?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are costs distributed?
tab <- data.frame(table(aux$`How are costs distributed?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are costs distributed?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How often will the agreement be renegotiated?
tab <- data.frame(table(aux$`How often will the agreement be renegotiated?`))
names(tab) <- c('Levels', 'Frequency')
p <- ggplot(data=tab, aes(x = Levels, y = Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How often will the agreement be renegotiated?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p
```

The two remarkable issues are the low frequency of *Less penalty* in the attribute *How are repeated violations punished?* and the low frequency of *None* for the attribute *What punishments do they use?*. This because when we draw the level none for the attribute *What punishments do they use?* or the level less penalty for *How are repeated violations punished?*, then it makes no sense to have less penalty than the minimum possible.

# Code for the Main Paper

The code for Figure 2 of the paper follows below. We also include the point estimates in companion tables.

```{r codefig2}
## Main plot
# Main estimation equation
fm <- selected ~ `Who makes the rules?` +
  `How are conflicts resolved?` +
  `What punishments do they use?` +
  `How are repeated violations punished?` +
  `How are costs distributed?` +
  `How often will the agreement be renegotiated?`

# Plot
mms <- mm(cj, fm, id = ~Response.ID, alpha = .1, h0 = 0.5)

myFaces <- c(rep('plain', 5), "bold",
             rep('plain', 4), "bold",
             rep('plain', 3), "bold",
             rep('plain', 4), "bold",
             rep('plain', 5), "bold",
             rep('plain', 5), "bold")

p <- plot(mms, vline = 0.5, header_fmt = "%s", size = 2) + ggplot2::theme(
    legend.position = "none",
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.text.y = element_text(face=myFaces, size = 11)) +
    ggplot2::geom_errorbarh(ggplot2::aes_string(xmin = "lower",
                                                xmax = "upper"),
                            size = 1, height = 0, na.rm = TRUE,
                            position = ggstance::position_dodgev(height = 1))
p

ggsave(filename = 'MM_all.pdf', plot = p, width = 8, height = 6)

# Table
table_mm <- function(mms, capt) {
  dfr <- data.frame(feature = mms[,c(4)],
             round(mms[,c(5,6,8,9,10)], digits=3))
  names(dfr) <- c('Feature', 'Estimate', 'Std.Error',
                'P-Value', 'Lower', 'Upper')
  return(kable(dfr, "latex", caption = capt, booktabs = T) %>%
    kable_styling(font_size = 10) %>%
    group_rows('Who makes the rules?', 1, 5) %>%
    group_rows('How are conflicts resolved?', 6, 10) %>%
    group_rows('What punishments do they use?', 11, 14) %>%
    group_rows('How are repeated violations punished?', 15, 17) %>%
    group_rows('How are costs distributed?', 18, 21) %>%
    group_rows('How often will the agreement be renegotiated?', 22, 26))
}

table_mm(mms, capt = 'Marginal Means -- Full Dataset')
```

The code for Figure 3 of the paper follows below, with also the point estimates in a companion table.

\newpage

```{r codefig3}
## Marginal means by Country

# Argentina
arg <- mm(subset(cj, countryOrigin=='Argentina'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(arg, capt = 'Marginal Means -- Argentina Only')
```

\newpage

```{r}
# Bolivia
bol <- mm(subset(cj, countryOrigin=='Bolivia'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(bol, capt = 'Marginal Means -- Bolivia Only')
```

\newpage

```{r}
# Brazil
bra <- mm(subset(cj, countryOrigin=='Brazil'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(bra, capt = 'Marginal Means -- Brazil Only')
```

\newpage

```{r}
# Chile
chi <- mm(subset(cj, countryOrigin=='Chile'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(chi, capt = 'Marginal Means -- Chile Only')
```

\newpage

```{r}
# Colombia
col <- mm(subset(cj, countryOrigin=='Colombia'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(col, capt = 'Marginal Means -- Colombia Only')
```

\newpage

```{r}
# Costa Rica
cri <- mm(subset(cj, countryOrigin=='Costa Rica'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(cri, capt = 'Marginal Means -- Costa Rica Only')
```

\newpage

```{r}
# Ecuador
ecu <- mm(subset(cj, countryOrigin=='Ecuador'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(ecu, capt = 'Marginal Means -- Ecuador Only')
```

\newpage

```{r}
# Mexico
mex <- mm(subset(cj, countryOrigin=='Mexico'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(mex, capt = 'Marginal Means -- Mexico Only')
```

\newpage

```{r}
# Panama
pan <- mm(subset(cj, countryOrigin=='Panama'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(pan, capt = 'Marginal Means -- Panama Only')
```

\newpage

```{r}
# Peru
per <- mm(subset(cj, countryOrigin=='Peru'),
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(per, capt = 'Marginal Means -- Peru Only')
```

\newpage

```{r, fig.width = 13, fig.height = 13}
# Changing country labels
arg$country <- 'Argentina'
bol$country <- 'Bolivia'
bra$country <- 'Brazil'
chi$country <- 'Chile'
col$country <- 'Colombia'
cri$country <- 'Costa Rica'
ecu$country <- 'Ecuador'
mex$country <- 'Mexico'
pan$country <- 'Panama'
per$country <- 'Peru'
# Plot by country
p <- plot(rbind(arg, bol, bra, chi, col,
              cri, ecu, mex, pan, per),
        group = 'country', vline = 0.5, nr = 10,
        header_fmt = "%s", size = 2) +
  facet_wrap( ~ country, ncol = 5) +
  ggplot2::theme(
    axis.text.y = element_text(face=myFaces, size = 11)) +
    ggplot2::geom_errorbarh(ggplot2::aes_string(xmin = "lower",
                                                xmax = "upper"),
                            size = 1, height = 0, na.rm = TRUE,
                            position = ggstance::position_dodgev(height = 1))

p

ggsave(filename = 'MM_country.pdf',
       plot = p, width = 12, height = 12)
```

The code for Figure 4 of the paper is available below. Tables displaying the point estimates are also included.

```{r}
## Elite type graphs and estimates

# Table for the Executive branch
res1 <- mm(subset(cj, groupOrigin=='Executive'),
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res1, capt = 'Marginal Means -- Executive Only')
```

\newpage

```{r}
# Legislative branch
res2 <- mm(subset(cj, groupOrigin=='Legislative'),
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res2, capt = 'Marginal Means -- Legislative Only')
```

\newpage

```{r}
# Civil society
res3 <- mm(subset(cj, groupOrigin=='Civil Society'),
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res3, capt = 'Marginal Means -- Civil Society Only')
```

\newpage

```{r}
# Academia
res4 <- mm(subset(cj, groupOrigin=='Academia'),
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res4, capt = 'Marginal Means -- Academia Only')

```

\newpage

```{r, fig.width = 10, fig.height = 8}
# Changing labels
res1$MemberType <- 'Executive'
res2$MemberType <- 'Legislative'
res3$MemberType <- 'Civil Society'
res4$MemberType <- 'Academia'

# Plot by Elite Type
p <- plot(rbind(res1, res2, res3, res4),
     group = 'MemberType', vline = 0.5, nr = 4,
        header_fmt = "%s", size = 2) +
  facet_wrap( ~ MemberType, ncol = 4) +
  ggplot2::theme(
    axis.text.y = element_text(face=myFaces, size = 11)) +
    ggplot2::geom_errorbarh(ggplot2::aes_string(xmin = "lower",
                                                xmax = "upper"),
                            size = 1, height = 0, na.rm = TRUE,
                            position = ggstance::position_dodgev(height = 1))
p

ggsave(filename = 'MM_membertype.pdf', plot = p,
       width = 8, height = 6)
```

# APSA Experimental Section Standard Report for Experiments 
\label{sec:apsa}

## Hypotheses

We designed three survey experiments to investigate (i) which criminal profiles
citizens prefer for extralegal punishment, (ii) how individuals justify mob
violence, and (iii) whether information provision reduces support for
vigilantism. First, we run a conjoint experiment to identify criminal
characteristics that are associated with higher likelihood of lynching. In our
second experiment, we show respondents a short article about a real lynching
episode and ask them whether they see the mob's motivations as legitimate.
Lastly, we test whether providing information about the legal consequences of
lynching, human rights guarantees, and the risk of retribution makes
respondents less likely to endorse extralegal violence. 

## Subjects and Context

We selected Brazilian nationals over 18 years of age to participate in our
experiments. Our sample consisted of XXXX participants from all 5 Brazilian
regions (Center-West, North, Northeast, Southeast, and South). 

We ran our online survey via Qualtrics. The firm recruited participants from
XXXX to XXXX December, 2020. From the XXXX responded contacted by Qualtrics,
XXXX declined to participate in our experiment (XX%), and XXX agreed to our
consent form (XX%).

## Allocation Methods

**Random Assignment:** We created the conjoint experiment using a Python application provided by @strezhnev2013conjoint. We translated the original survey questions (as shown in the text) into Portuguese, then embedded the PHP file with the randomization parameters in a Qualtrics survey. The PHP code we used to randomize the values of the attributes is available at the project's GitHub repository: <https://github.com/danilofreire/lynching-experiment-brazil/tree/master/conjoint>.

For each attribute, the probability of selecting a given component follows a uniform distribution function. The table below describes the results.

\vspace{.5cm}

| **Attribute**                          | **Values**                                   | **Probabilities** |
|:---------------------------------------|:---------------------------------------------|------------------:|
| **Who makes the rules?**               | International organizations                  | 1/5               |
|                                        | Federal government                           | 1/5               |
|                                        | Local government                             | 1/5               |
|                                        | Local community members                      | 1/5               |
|                                        | Non-governmental organizations               | 1/5               |
|                                        |                                              |                   |
| **Conflict resolution mechanism**      | United Nations                               | 1/5               |
|                                        | Government bureaucracy                       | 1/5               |
|                                        | Local courts                                 | 1/5               |
|                                        | Private arbitration                          | 1/5               |
|                                        | Informal norms                               | 1/5               |
|                                        |                                              |                   |
| **Punishment**                         | Imprisonment                                 | 1/4               |
|                                        | Fines                                        | 1/4               |
|                                        | Blacklist                                    | 1/4               |
|                                        | None                                         | 1/4               |
|                                        |                                              |                   |
| **Punishment for repeated violations** | More penalty                                 | 1/3               |
|                                        | Same                                         | 1/3               |
|                                        | Less penalty                                 | 1/3               |
|                                        |                                              |                   |
| **Agreement costs**                    | Rich countries pay more than poor countries  | 1/4               |
|                                        | Proportional to history of emissions         | 1/4               |
|                                        | Proportional to current emissions            | 1/4               |
|                                        | Only rich countries pay                      | 1/4               |
|                                        |                                              |                   |
| **Renegotiation**                      | Never                                        | 1/5               |
|                                        | Fifty years                                  | 1/5               |
|                                        | Twenty years                                 | 1/5               |
|                                        | Five years                                   | 1/5               |
|                                        | One year                                     | 1/5               |
Table: Conjoint experiment attributes and their respective probabilities.

We added one logical restriction to the set climate change treaties: **Punishment = None** can never appear together with **Punishment for repeated violations = Less penalty**. The number of possible treaties are the product of the attributes ($5\times 5 \times 4 \times 3 \times 4 \times 5 = 6,000$) minus the number of removed possibilities ($5\times 5  \times 4 \times 5 = 500$). The total number of possible treaties is $5,500$.

## Treatments

**Descriptions of the intervention:** Our treatment was the randomization of components in the conjoined climate mitigation treaties. We provided the following description before the conjoint experiment starts, in Spanish and Portuguese:

\vspace{.5cm}

```
For the following questions, read carefully the instructions below.

Imagine that your country would sign an international treaty to mitigate climate change.
A climate mitigation treaty has, in general, the following attributes:

1. Who defines the rules? Which group will define the parameters for the treaty?
2. How are the conflicts that might happen when the treaty begin be resolved?
3. What punishments should be applied to ensure compliance?
4. How will repeated violations be punished?
5. How are costs for implementing the treaty be distributed?
6. How often the treaty has to be renegotiated?

In the following questions, you will see variations in treaties on these six attributes.
Please select the treaty that has the characteristics that you believe are best for your country.
```

\vspace{.5cm}

The conjoint experiment consisted in comparing two treaties that vary in these six attributes, repeating the application for seven times for each respondent.

\noindent \textbf{Software:} To program the PHP randomization device we used the Python application provided by @strezhnev2013conjoint. We used Qualtrics to administer the survey.

\noindent \textbf{Delivery:} We repeated the conjoint experiment seven times, to improve test power.

\noindent \textbf{Dataset description:} Each line in the dataset represents a given treaty, varying for the selection status (selected versus non-selected) for a given respondent. When a respondent finished an entire response set, this adds 14 rows to the dataset. Seven rows with the selected treaties and other seven rows with the non-selected treaties.

\noindent \textbf{Deception:} We used no deception in our experiments.

## Results 

\noindent \textbf{Outcome measures and covariates:} The main outcome is a binary indicator for the selection of a given conjoined package. We added two covariates to measure heterogeneous effects: *Country* and *Elite type*.

\noindent \textbf{Questionnaire:} For the English translation of the entire survey instrument, with both the telephone and the online components, see the attachment below.

\noindent \textbf{Statistical analysis:} We fit a marginal means estimator and an AMCE estimator. The estimation conditions the results within subjects and the presented conjoined packages. The results are available in sections \ref{sec:features} and \ref{sec:amce}.

\noindent \textbf{Missing data and attrition:} Conditional on having started the conjoint experiment, for each task we had the following completion rates:

```{r, fig.width = 7, fig.height = 8}
barplot(100*table(cj$task)/max(table(cj$task)), xlab = 'Conjoint task', ylab = 'Percentage completed')
```

## Other Information

* **IRB**: This research received IRB approval from Brown University (Protocol 2009002803/2020).

* **Pre-registration**: We submitted the study design to EGAP's registry on
  October 30th, 2020. A time-stamped copy of the pre-analysis plan is available
  at
  <https://github.com/danilofreire/lynching-experiment-brazil/tree/master/pre-analysis-plan>

* **Funding**: We received $10,000 from the Department of Political Economy at
  King's College London to conduct this research. The study sponsor did not
  play a role in the design or analysis of the study or in the decision to
  submit for publication.

* **Replication materials**: All scripts and data required to replicate the
  results of our study are available at
  <http://github.com/danilofreire/lynching-experiment-brazil>.

# Session Information
\label{sec:session-info}

```{r session, cache=TRUE}
sessionInfo()
```

# References
